'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/*
  GraphView is a Generic D3 Graph view with no application specific
  code in it and no significant state except UI state (zoom, for example).
*/

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _d = require('d3');

var d3 = _interopRequireWildcard(_d);

var _radium = require('radium');

var _radium2 = _interopRequireDefault(_radium);

var _graphControls = require('./graph-controls.js');

var _graphControls2 = _interopRequireDefault(_graphControls);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// The work area is infinite, but the point grid is fixed
var gridSize = 40960;
var gridSpacing = 36;
var gridDot = 2;

var minZoom = 0.15;
var maxZoom = 1.5;

var nodeSize = 150;
var edgeHandleSize = 50;
var edgeArrowSize = 8;
var transitionTime = 150; // D3 Enter/Exit duration

// FIXME: This is unreasonably constrained - 
// but works for the worst case: "WWWWWWWWW".
var maxTitleChars = 9; // Per line. 

var zoomDelay = 500; // ms
var zoomDur = 750; // ms


function styleToString(style) {
  return Object.keys(style).map(function (k) {
    var key = k.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    return key + ':' + style[k];
  }).join(";");
}

function makeStyles() {
  var primary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'dodgerblue';
  var light = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'white';
  var dark = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'black';

  var styles = {
    wrapper: {
      base: {
        height: '100%',
        margin: 0,
        display: 'flex',
        boxShadow: 'none',
        opacity: 0.5,
        background: '#F9F9F9'
      },
      focused: {
        opacity: 1
      }
    },
    svg: {
      base: {
        alignContent: 'stretch',
        flex: 1
      }
    },
    node: {
      base: {
        color: primary,
        stroke: light,
        fill: light,
        filter: 'url(#dropshadow)',
        strokeWidth: '0.5px',
        cursor: 'pointer'
      },
      selected: {
        color: light,
        stroke: primary,
        fill: primary
      }
    },
    shape: {
      fill: 'inherit',
      stroke: dark,
      strokeWidth: '0.5px'
    },
    text: {
      base: {
        fill: dark,
        stroke: dark
      },
      selected: {
        fill: light,
        stroke: light
      }
    },
    edge: {
      base: {
        color: light,
        stroke: primary,
        strokeWidth: '2px',
        markerEnd: 'url(#end-arrow)',
        cursor: 'pointer'
      },
      selected: {
        color: primary,
        stroke: primary
      }
    },
    arrow: {
      fill: primary
    }
  };

  // Styles need to be strings for D3 to apply them all at once
  styles.node.baseString = styleToString(styles.node.base);
  styles.node.selectedString = styleToString(_extends({}, styles.node.base, styles.node.selected));
  styles.text.baseString = styleToString(styles.text.base);
  styles.text.selectedString = styleToString(_extends({}, styles.text.base, styles.text.selected));
  styles.edge.baseString = styleToString(styles.edge.base);
  styles.edge.selectedString = styleToString(_extends({}, styles.edge.base, styles.edge.selected));

  return styles;
}

// any objects with x & y properties
function getTheta(pt1, pt2) {
  var xComp = pt2.x - pt1.x;
  var yComp = pt2.y - pt1.y;
  var theta = Math.atan2(yComp, xComp);
  return theta;
}

function getMidpoint(pt1, pt2) {
  var x = (pt2.x + pt1.x) / 2;
  var y = (pt2.y + pt1.y) / 2;

  return { x: x, y: y };
}

function getDistance(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}

var GraphView = function (_Component) {
  _inherits(GraphView, _Component);

  function GraphView(props) {
    _classCallCheck(this, GraphView);

    // Bind methods
    var _this = _possibleConstructorReturn(this, (GraphView.__proto__ || Object.getPrototypeOf(GraphView)).call(this, props));

    _this.hideEdge = _this.hideEdge.bind(_this);
    _this.showEdge = _this.showEdge.bind(_this);
    _this.canSwap = _this.canSwap.bind(_this);
    _this.drawEdge = _this.drawEdge.bind(_this);
    _this.dragNode = _this.dragNode.bind(_this);
    _this.handleNodeDrag = _this.handleNodeDrag.bind(_this);
    _this.handleDelete = _this.handleDelete.bind(_this);
    _this.handleWindowKeydown = _this.handleWindowKeydown.bind(_this);
    _this.handleWindowClicked = _this.handleWindowClicked.bind(_this);
    _this.handleSvgClicked = _this.handleSvgClicked.bind(_this);
    _this.handleNodeMouseDown = _this.handleNodeMouseDown.bind(_this);
    _this.handleNodeMouseUp = _this.handleNodeMouseUp.bind(_this);
    _this.handleNodeMouseEnter = _this.handleNodeMouseEnter.bind(_this);
    _this.handleNodeMouseLeave = _this.handleNodeMouseLeave.bind(_this);
    _this.arrowClicked = _this.arrowClicked.bind(_this);
    _this.handleEdgeDrag = _this.handleEdgeDrag.bind(_this);
    _this.handleEdgeMouseDown = _this.handleEdgeMouseDown.bind(_this);
    _this.containZoom = _this.containZoom.bind(_this);
    _this.handleZoom = _this.handleZoom.bind(_this);
    _this.handleZoomToFit = _this.handleZoomToFit.bind(_this);
    _this.modifyZoom = _this.modifyZoom.bind(_this);
    _this.setZoom = _this.setZoom.bind(_this);
    _this.getPathDescriptionStr = _this.getPathDescriptionStr.bind(_this);
    _this.getPathDescription = _this.getPathDescription.bind(_this);
    _this.getEdgeHandleTransformation = _this.getEdgeHandleTransformation.bind(_this);
    _this.getNodeTransformation = _this.getNodeTransformation.bind(_this);
    _this.getNodeStyle = _this.getNodeStyle.bind(_this);
    _this.getEdgeStyle = _this.getEdgeStyle.bind(_this);
    _this.getTextStyle = _this.getTextStyle.bind(_this);
    _this.renderNodeText = _this.renderNodeText.bind(_this);
    _this.renderEdges = _this.renderEdges.bind(_this);
    _this.renderNodes = _this.renderNodes.bind(_this);
    _this.renderView = _this.renderView.bind(_this);

    _this.state = {
      viewTransform: d3.zoomIdentity,
      selectionChanged: false,
      focused: true,
      readOnly: props.readOnly || false,
      enableFocus: props.enableFocus || false, // Enables focus/unfocus
      edgeSwapQueue: [], // Stores nodes to be swapped
      styles: makeStyles(props.primary, props.light, props.dark),
      nodeDefs: Object.keys(props.nodeTypes).map(function (type) {
        return props.nodeTypes[type].shape;
      }), // SVG definitions for nodes
      nodeSubtypeDefs: Object.keys(props.nodeSubtypes).map(function (type) {
        return props.nodeSubtypes[type].shape;
      }),
      edgeDefs: Object.keys(props.edgeTypes).map(function (type) {
        return props.edgeTypes[type].shape;
      }) // SVG definitions for edges
    };

    _this.zoom = d3.zoom().scaleExtent([minZoom, maxZoom]).on("zoom", _this.handleZoom);
    return _this;
  }

  _createClass(GraphView, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      // Window event listeners for keypresses
      // and to control blur/focus of graph
      d3.select(window).on('keydown', this.handleWindowKeydown).on('click', this.handleWindowClicked);

      var svg = d3.select(this.refs.viewWrapper).on("touchstart", this.containZoom).on("touchmove", this.containZoom).on("click", this.handleSvgClicked).select("svg").call(this.zoom);

      // On the initial load, the 'view' <g> doesn't exist
      // until componentDidMount. Manually render the first view.
      this.renderView();

      setTimeout(function () {
        this.handleZoomToFit();
      }.bind(this), zoomDelay);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      // Remove window event listeners
      d3.select(window).on('keydown', null).on('click', null);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var selectionChanged = false;
      var selected = this.props.selected;

      if (selected != nextProps.selected) {
        selectionChanged = true;
      }

      var selectionType = null;
      if (nextProps.selected && nextProps.selected.source) {
        selectionType = 'edge';
      } else if (nextProps.selected && nextProps.selected[this.props.nodeKey]) {
        selectionType = 'node';
      }

      this.setState({
        selectionChanged: selectionChanged,
        selectionType: selectionType,
        readOnly: nextProps.readOnly || false
      });
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.state.selectionChanged) {
        this.setState({
          selectionChanged: false
        });
      }
    }

    /*
     * Handlers/Interaction
     */

  }, {
    key: 'hideEdge',
    value: function hideEdge(edgeDOMNode) {
      d3.select(edgeDOMNode).attr("opacity", 0);
    }
  }, {
    key: 'showEdge',
    value: function showEdge(edgeDOMNode) {
      d3.select(edgeDOMNode).attr("opacity", 1);
    }
  }, {
    key: 'canSwap',
    value: function canSwap(sourceNode, hoveredNode, swapEdge) {
      return swapEdge.source != sourceNode[this.props.nodeKey] || swapEdge.target != hoveredNode[this.props.nodeKey];
    }
  }, {
    key: 'drawEdge',
    value: function drawEdge(sourceNode, target, swapErrBack) {
      var self = this;

      var dragEdge = d3.select(this.refs.entities).append('svg:path');

      dragEdge.attr('class', 'link dragline').attr("style", this.state.styles.edge.selectedString).attr('d', self.getPathDescriptionStr(sourceNode.x, sourceNode.y, target.x, target.y));

      d3.event.on("drag", dragged).on("end", ended);

      function dragged(d) {
        dragEdge.attr('d', self.getPathDescriptionStr(sourceNode.x, sourceNode.y, d3.event.x, d3.event.y));
      }

      function ended(d) {
        dragEdge.remove();

        var swapEdge = self.state.edgeSwapQueue.shift();
        var hoveredNode = self.state.hoveredNode;

        self.setState({
          edgeSwapQueue: self.state.edgeSwapQueue,
          drawingEdge: false
        });

        if (hoveredNode && self.props.canCreateEdge(sourceNode, hoveredNode)) {

          if (swapEdge) {
            if (self.props.canDeleteEdge(swapEdge) && self.canSwap(sourceNode, hoveredNode, swapEdge)) {
              self.props.onSwapEdge(sourceNode, hoveredNode, swapEdge);
            } else {
              swapErrBack();
            }
          } else {
            self.props.onCreateEdge(sourceNode, hoveredNode);
          }
        } else {
          if (swapErrBack) {
            swapErrBack();
          }
        }
      }
    }
  }, {
    key: 'dragNode',
    value: function dragNode() {
      var self = this;

      var el = d3.select(d3.event.target.parentElement); // Enclosing 'g' element
      el.classed("dragging", true);
      d3.event.on("drag", dragged).on("end", ended);

      function dragged(d) {
        if (self.state.readOnly) return;
        d3.select(this).attr('transform', function (d) {
          d.x += d3.event.dx;
          d.y += d3.event.dy;
          return 'translate(' + d.x + ',' + d.y + ')';
        });
        self.render();
      }

      function ended() {
        el.classed("dragging", false);

        if (!self.state.readOnly) {
          var d = d3.select(this).datum();
          self.props.onUpdateNode(d);
        }

        // For some reason, mouseup isn't firing 
        // - manually firing it here
        d3.select(this).node().dispatchEvent(new Event("mouseup"));
      }
    }

    // Node 'drag' handler

  }, {
    key: 'handleNodeDrag',
    value: function handleNodeDrag() {
      if (this.state.drawingEdge && !this.state.readOnly) {
        var target = { x: d3.event.subject.x, y: d3.event.subject.y };
        this.drawEdge(d3.event.subject, target);
      } else {
        this.dragNode();
      }
    }
  }, {
    key: 'handleDelete',
    value: function handleDelete() {
      if (this.state.readOnly) return;
      if (this.props.selected) {
        var selected = this.props.selected;
        if (this.state.selectionType === 'node' && this.props.canDeleteNode(selected)) {
          this.props.onDeleteNode(selected);
          this.props.onSelectNode(null);
        } else if (this.state.selectionType === 'edge' && this.props.canDeleteEdge(selected)) {
          this.props.onDeleteEdge(selected);
          this.props.onSelectNode(null);
        }
      }
    }
  }, {
    key: 'handleWindowKeydown',
    value: function handleWindowKeydown(d, i) {
      // Conditionally ignore keypress events on the window 
      // if the Graph isn't focused
      if (this.state.focused) {
        switch (d3.event.key) {
          case "Delete":
            this.handleDelete();
            break;
          case "Backspace":
            this.handleDelete();
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: 'handleWindowClicked',
    value: function handleWindowClicked(d, i) {
      if (this.state.focused && !event.target.ownerSVGElement) {
        if (this.state.enableFocus) {
          this.setState({
            focused: false
          });
        }
      }
    }
  }, {
    key: 'handleSvgClicked',
    value: function handleSvgClicked(d, i) {
      if (!this.state.focused) {
        this.setState({
          focused: true
        });
      }

      if (this.state.selectingNode) {
        this.setState({
          selectingNode: false
        });
      } else {

        this.props.onSelectNode(null);

        if (!this.state.readOnly && d3.event.shiftKey) {
          var xycoords = d3.mouse(event.target);
          this.props.onCreateNode(xycoords[0], xycoords[1]);
        }
      }
    }
  }, {
    key: 'handleNodeMouseDown',
    value: function handleNodeMouseDown(d) {
      if (d3.event.defaultPrevented) return; // dragged

      if (d3.event.shiftKey) {

        this.setState({
          selectingNode: true,
          drawingEdge: true,
          focused: true
        });
      } else {
        this.setState({
          selectingNode: true,
          focused: true
        });
      }
    }
  }, {
    key: 'handleNodeMouseUp',
    value: function handleNodeMouseUp(d) {

      if (this.state.selectingNode) {
        this.props.onSelectNode(d);
        this.setState({ selectingNode: false });
      }
    }
  }, {
    key: 'handleNodeMouseEnter',
    value: function handleNodeMouseEnter(d) {

      if (this.state.hoveredNode != d) {
        this.setState({
          hoveredNode: d
        });
      }
    }
  }, {
    key: 'handleNodeMouseLeave',
    value: function handleNodeMouseLeave(d) {

      // For whatever reason, mouseLeave is fired when edge dragging ends 
      // (and mouseup is not fired). This clears the hoverNode state prematurely
      // resulting in swapEdge failing to fire. 
      // Detecting & ignoring mouseLeave events that result from drag ending here
      var fromMouseup = event.which == 1;
      if (this.state.hoveredNode === d && !fromMouseup) {
        this.setState({
          hoveredNode: null
        });
      }
    }

    // One can't attach handlers to 'markers' or obtain them from the event.target
    // If the click occurs within a certain radius of edge target,
    // assume the click occurred on the arrow

  }, {
    key: 'arrowClicked',
    value: function arrowClicked(d) {

      if (event.target.tagName != 'path') return false; // If the handle is clicked

      var xycoords = d3.mouse(event.target);
      var target = this.props.getViewNode(d.target);
      var dist = getDistance({ x: xycoords[0], y: xycoords[1] }, target);

      return dist < nodeSize / 2 + edgeArrowSize + 10; // or *2 or ^2?
    }
  }, {
    key: 'handleEdgeDrag',
    value: function handleEdgeDrag(d) {
      if (!this.state.readOnly && this.state.drawingEdge) {
        var edgeDOMNode = event.target.parentElement;
        var sourceNode = this.props.getViewNode(d.source);
        var xycoords = d3.mouse(event.target);
        var target = { x: xycoords[0], y: xycoords[1] };

        this.hideEdge(edgeDOMNode);
        this.drawEdge(sourceNode, target, this.showEdge.bind(this, edgeDOMNode));
      }
    }
  }, {
    key: 'handleEdgeMouseDown',
    value: function handleEdgeMouseDown(d) {

      if (!this.state.readOnly && this.arrowClicked(d)) {
        this.state.edgeSwapQueue.push(d); // Set this edge aside for redrawing
        this.setState({
          drawingEdge: true,
          edgeSwapQueue: this.state.edgeSwapQueue,
          focused: true
        });
      } else {
        this.props.onSelectEdge(d);
        this.setState({
          focused: true
        });
      }
    }

    // Keeps 'zoom' contained

  }, {
    key: 'containZoom',
    value: function containZoom() {
      d3.event.preventDefault();
    }

    // View 'zoom' handler

  }, {
    key: 'handleZoom',
    value: function handleZoom() {
      if (this.state.focused) {
        this.setState({
          viewTransform: d3.event.transform
        });
      }
    }

    // Zooms to contents of this.refs.entities

  }, {
    key: 'handleZoomToFit',
    value: function handleZoomToFit() {
      var parent = d3.select(this.refs.viewWrapper).node();
      var entities = d3.select(this.refs.entities).node();

      // If the component is used headlessly (testing, etc...), 
      // this method is sometimes absent
      if (typeof entities.getBBox === 'undefined') {
        console.warn("Node has no method called getBBox");return;
      }

      var viewBBox = entities.getBBox();

      var width = parent.clientWidth;
      var height = parent.clientHeight;

      var dx = void 0,
          dy = void 0,
          x = void 0,
          y = void 0,
          translate = [this.state.viewTransform.x, this.state.viewTransform.y],
          next = { x: translate[0], y: translate[1], k: this.state.viewTransform.k };

      if (viewBBox.width > 0 && viewBBox.height > 0) {
        // There are entities
        dx = viewBBox.width, dy = viewBBox.height, x = viewBBox.x + viewBBox.width / 2, y = viewBBox.y + viewBBox.height / 2;

        next.k = .9 / Math.max(dx / width, dy / height);

        if (next.k < minZoom) {
          next.k = minZoom;
        } else if (next.k > maxZoom) {
          next.k = maxZoom;
        }

        next.x = width / 2 - next.k * x;
        next.y = height / 2 - next.k * y;
      } else {
        next.k = (minZoom + maxZoom) / 2;
        next.x = 0;
        next.y = 0;
      }

      this.setZoom(next.k, next.x, next.y, zoomDur);
    }

    // Updates current viewTransform with some delta

  }, {
    key: 'modifyZoom',
    value: function modifyZoom() {
      var modK = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var modX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var modY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var dur = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var parent = d3.select(this.refs.viewWrapper).node();
      var width = parent.clientWidth;
      var height = parent.clientHeight;

      var target_zoom = void 0,
          center = [width / 2, height / 2],
          extent = this.zoom.scaleExtent(),
          translate = [this.state.viewTransform.x, this.state.viewTransform.y],
          translate0 = [],
          l = [],
          next = { x: translate[0], y: translate[1], k: this.state.viewTransform.k };

      target_zoom = next.k * (1 + modK);

      if (target_zoom < extent[0] || target_zoom > extent[1]) {
        return false;
      }

      translate0 = [(center[0] - next.x) / next.k, (center[1] - next.y) / next.k];
      next.k = target_zoom;
      l = [translate0[0] * next.k + next.x, translate0[1] * next.k + next.y];

      next.x += center[0] - l[0] + modX;
      next.y += center[1] - l[1] + modY;

      this.setZoom(next.k, next.x, next.y, dur);
    }

    // Programmatically resets zoom

  }, {
    key: 'setZoom',
    value: function setZoom() {
      var k = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var dur = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;


      var t = d3.zoomIdentity.translate(x, y).scale(k);

      d3.select('svg').transition().duration(dur).call(this.zoom.transform, t);
    }

    /*
     * Render
     */
    // Returns the svg's path.d' (geometry description) string from edge data
    // edge.source and edge.target are node ids

  }, {
    key: 'getPathDescriptionStr',
    value: function getPathDescriptionStr(sourceX, sourceY, targetX, targetY) {
      return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
    }
  }, {
    key: 'getPathDescription',
    value: function getPathDescription(edge) {
      var src = this.props.getViewNode(edge.source);
      var trg = this.props.getViewNode(edge.target);

      if (src && trg) {
        var off = nodeSize / 2; // from the center of the node to the perimeter

        var theta = getTheta(src, trg);

        var xOff = off * Math.cos(theta);
        var yOff = off * Math.sin(theta);

        return this.getPathDescriptionStr(src.x + xOff, src.y + yOff, trg.x - xOff, trg.y - yOff);
      }
      console.warn("Unable to get source or target for ", edge);
      return "";
    }
  }, {
    key: 'getEdgeHandleTransformation',
    value: function getEdgeHandleTransformation(edge) {
      var src = this.props.getViewNode(edge.source);
      var trg = this.props.getViewNode(edge.target);

      var origin = getMidpoint(src, trg);
      var x = origin.x;
      var y = origin.y;
      var theta = getTheta(src, trg) * 180 / Math.PI;
      var offset = -edgeHandleSize / 2;

      return 'translate(' + x + ', ' + y + ') rotate(' + theta + ') translate(' + offset + ', ' + offset + ')';
    }

    // Returns a d3 transformation string from node data

  }, {
    key: 'getNodeTransformation',
    value: function getNodeTransformation(node) {
      return 'translate(' + node.x + ',' + node.y + ')';
    }
  }, {
    key: 'getNodeStyle',
    value: function getNodeStyle(d, selected) {
      return d === selected ? this.state.styles.node.selectedString : this.state.styles.node.baseString;
    }
  }, {
    key: 'getEdgeStyle',
    value: function getEdgeStyle(d, selected) {
      return d === selected ? this.state.styles.edge.selectedString : this.state.styles.edge.baseString;
    }
  }, {
    key: 'getTextStyle',
    value: function getTextStyle(d, selected) {
      return d === selected ? this.state.styles.text.selectedString : this.state.styles.text.baseString;
    }

    // Renders 'node.title' into node element

  }, {
    key: 'renderNodeText',
    value: function renderNodeText(d, domNode) {
      var d3Node = d3.select(domNode);
      var title = d.title;

      var titleText = title.length < maxTitleChars ? title : title.substring(0, maxTitleChars) + '...';

      var lineOffset = 18;
      var textOffset = d.type === this.props.emptyType ? -9 : 18;

      d3Node.selectAll("text").remove();

      var typeText = this.props.nodeTypes[d.type].typeText;
      var style = this.getTextStyle(d, this.props.selected);

      var el = d3Node.append('text').attr('text-anchor', 'middle').attr('style', style).attr('dy', textOffset);

      el.append('tspan').attr('opacity', 0.5).text(typeText);

      if (title) {
        // User defined/secondary text
        el.append('tspan').text(titleText).attr('x', 0).attr('dy', lineOffset);

        el.append('title').text(title);
      }
    }

    // Renders 'edges' into entities element

  }, {
    key: 'renderEdges',
    value: function renderEdges(entities, edges) {
      var self = this;

      // Join Data
      var edges = entities.selectAll("g.edge").data(edges, function (d) {
        // IMPORTANT: this snippet allows D3 to detect updated vs. new data
        return d.source + ':' + d.target;
      });
      // Remove Old
      edges.exit().remove();

      // Add New
      var newEdges = edges.enter().append("g").classed("edge", true);

      newEdges.on("mousedown", this.handleEdgeMouseDown).call(d3.drag().on("start", this.handleEdgeDrag));

      newEdges.attr("opacity", 0).transition().duration(transitionTime).attr("opacity", 1);

      newEdges.append('path');
      newEdges.append("use");

      // Merge 
      edges.enter().merge(edges);

      // Update All
      entities.selectAll('g.edge').each(function (d, i, els) {

        var style = self.getEdgeStyle(d, self.props.selected);
        var trans = self.getEdgeHandleTransformation(d);
        d3.select(this).attr("style", style).select("use").attr("xlink:href", function (d) {
          return self.props.edgeTypes[d.type].shapeId;
        }).attr("width", edgeHandleSize).attr("height", edgeHandleSize).attr("transform", trans);
      }).select('path').attr('d', this.getPathDescription);
    }

    // Renders 'nodes' into entities element

  }, {
    key: 'renderNodes',
    value: function renderNodes(entities, nodes) {
      var self = this;
      var nodeKey = this.props.nodeKey;

      // Join Data 
      var nodes = entities.selectAll("g.node").data(nodes, function (d) {
        // IMPORTANT: this snippet allows D3 to detect updated vs. new data
        return d[nodeKey];
      });

      // Animate/Remove Old 
      nodes.exit().transition().duration(transitionTime).attr("opacity", 0).remove();

      // Add New
      var newNodes = nodes.enter().append("g").classed("node", true);

      newNodes.attr("style", this.state.styles.node.baseString).on("mousedown", this.handleNodeMouseDown).on("mouseup", this.handleNodeMouseUp).on("mouseenter", this.handleNodeMouseEnter).on("mouseleave", this.handleNodeMouseLeave).call(d3.drag().on("start", this.handleNodeDrag));

      newNodes.append("use").classed("subtypeShape", true).attr("x", -nodeSize / 2).attr("y", -nodeSize / 2).attr("width", nodeSize).attr("height", nodeSize);

      newNodes.append("use").classed("shape", true).attr("x", -nodeSize / 2).attr("y", -nodeSize / 2).attr("width", nodeSize).attr("height", nodeSize);

      newNodes.attr("opacity", 0).transition().duration(transitionTime).attr("opacity", 1);

      // Merge
      nodes.enter().merge(nodes);

      // Update All
      entities.selectAll('g.node').each(function (d, i, els) {
        var style = self.getNodeStyle(d, self.props.selected);

        d3.select(this).attr("style", style);

        if (d.subtype) {
          d3.select(this).select("use.subtypeShape").attr("xlink:href", function (d) {
            return self.props.nodeSubtypes[d.subtype].shapeId;
          });
        } else {
          d3.select(this).select("use.subtypeShape").attr("xlink:href", function (d) {
            return null;
          });
        }

        d3.select(this).select("use.shape").attr("xlink:href", function (d) {
          return self.props.nodeTypes[d.type].shapeId;
        });

        self.renderNodeText(d, this);
      }).attr('transform', this.getNodeTransformation);
    }

    // Renders 'graph' into view element
    // All DOM updates within 'view' are managed by D3

  }, {
    key: 'renderView',
    value: function renderView() {
      var nodes = this.props.nodes;
      var edges = this.props.edges;

      // Update the view w/ new zoom/pan
      var view = d3.select(this.refs.view).attr("transform", this.state.viewTransform);

      var entities = d3.select(this.refs.entities);

      this.renderNodes(entities, nodes);
      this.renderEdges(entities, edges);
    }
  }, {
    key: 'render',
    value: function render() {
      this.renderView();
      var styles = this.state.styles;

      return _react2.default.createElement(
        'div',
        { id: 'viewWrapper',
          ref: 'viewWrapper',
          style: [styles.wrapper.base, !!this.state.focused && styles.wrapper.focused, this.props.style] },
        _react2.default.createElement(
          'svg',
          { id: 'svgRoot',
            style: styles.svg.base },
          _react2.default.createElement(
            'defs',
            null,
            this.state.nodeDefs,
            this.state.nodeSubtypeDefs,
            this.state.edgeDefs,
            _react2.default.createElement(
              'marker',
              { id: 'end-arrow',
                viewBox: '0 -' + edgeArrowSize / 2 + ' ' + edgeArrowSize + ' ' + edgeArrowSize,
                refX: '' + edgeArrowSize / 2,
                markerWidth: '' + edgeArrowSize,
                markerHeight: '' + edgeArrowSize,
                orient: 'auto' },
              _react2.default.createElement('path', { style: styles.arrow,
                d: 'M0,-' + edgeArrowSize / 2 + 'L' + edgeArrowSize + ',0L0,' + edgeArrowSize / 2 })
            ),
            _react2.default.createElement(
              'pattern',
              { id: 'grid',
                width: gridSpacing,
                height: gridSpacing,
                patternUnits: 'userSpaceOnUse' },
              _react2.default.createElement('circle', { cx: gridSpacing / 2,
                cy: gridSpacing / 2,
                r: gridDot,
                fill: 'lightgray' })
            ),
            _react2.default.createElement(
              'filter',
              { id: 'dropshadow', height: '130%' },
              _react2.default.createElement('feGaussianBlur', { 'in': 'SourceAlpha', stdDeviation: '3' }),
              _react2.default.createElement('feOffset', { dx: '2', dy: '2', result: 'offsetblur' }),
              _react2.default.createElement(
                'feComponentTransfer',
                null,
                _react2.default.createElement('feFuncA', { type: 'linear', slope: '0.1' })
              ),
              _react2.default.createElement(
                'feMerge',
                null,
                _react2.default.createElement('feMergeNode', null),
                _react2.default.createElement('feMergeNode', { 'in': 'SourceGraphic' })
              )
            )
          ),
          _react2.default.createElement(
            'g',
            { id: 'view', ref: 'view' },
            _react2.default.createElement('rect', { className: 'background',
              x: -gridSize / 4,
              y: -gridSize / 4,
              width: gridSize,
              height: gridSize,
              fill: 'url(#grid)' }),
            _react2.default.createElement('g', { id: 'entities', ref: 'entities' })
          ),
          '}'
        ),
        _react2.default.createElement(_graphControls2.default, { primary: this.props.primary,
          minZoom: minZoom,
          maxZoom: maxZoom,
          zoomLevel: this.state.viewTransform.k,
          zoomToFit: this.handleZoomToFit,
          modifyZoom: this.modifyZoom })
      );
    }
  }]);

  return GraphView;
}(_react.Component);

GraphView.propTypes = {
  primary: _react2.default.PropTypes.string,
  light: _react2.default.PropTypes.string,
  dark: _react2.default.PropTypes.string,
  style: _react2.default.PropTypes.object,
  nodeKey: _react2.default.PropTypes.string.isRequired,
  emptyType: _react2.default.PropTypes.string.isRequired,
  nodes: _react2.default.PropTypes.array.isRequired,
  edges: _react2.default.PropTypes.array.isRequired,
  readOnly: _react2.default.PropTypes.bool,
  enableFocus: _react2.default.PropTypes.bool,
  selected: _react2.default.PropTypes.object.isRequired,
  nodeTypes: _react2.default.PropTypes.object.isRequired,
  nodeSubtypes: _react2.default.PropTypes.object.isRequired,
  edgeTypes: _react2.default.PropTypes.object.isRequired,
  getViewNode: _react2.default.PropTypes.func.isRequired,
  onSelectNode: _react2.default.PropTypes.func.isRequired,
  onCreateNode: _react2.default.PropTypes.func.isRequired,
  onUpdateNode: _react2.default.PropTypes.func.isRequired,
  canDeleteNode: _react2.default.PropTypes.func,
  onDeleteNode: _react2.default.PropTypes.func.isRequired,
  onSelectEdge: _react2.default.PropTypes.func.isRequired,
  canCreateEdge: _react2.default.PropTypes.func,
  onCreateEdge: _react2.default.PropTypes.func.isRequired,
  onSwapEdge: _react2.default.PropTypes.func.isRequired,
  canDeleteEdge: _react2.default.PropTypes.func,
  onDeleteEdge: _react2.default.PropTypes.func.isRequired
};

GraphView.defaultProps = {
  primary: 'dodgerblue',
  light: '#FFF',
  dark: '#000',
  readOnly: false,
  canDeleteNode: function canDeleteNode() {
    return true;
  },
  canCreateEdge: function canCreateEdge() {
    return true;
  },
  canDeleteEdge: function canDeleteEdge() {
    return true;
  }
};

exports.default = (0, _radium2.default)(GraphView);
//# sourceMappingURL=graph-view.js.map